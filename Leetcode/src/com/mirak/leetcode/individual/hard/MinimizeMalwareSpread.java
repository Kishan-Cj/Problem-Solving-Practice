package com.mirak.leetcode.individual.hard;

import java.util.*;

public class MinimizeMalwareSpread {

  public int minMalwareSpread(int[][] graph, int[] initial) {

    int n = graph.length;

    if (n == 0) {
      return 0;
    }

    Arrays.sort(initial);

    ArrayList<Integer>[] adjList = new ArrayList[n];

    for (int i = 0; i < n; i++) {
      adjList[i] = new ArrayList<>();
    }

    for (int i = 0; i < n; i++) {
      for (int j = i + 1; j < n; j++) {
        if (graph[i][j] == 1) {
          adjList[i].add(j);
          adjList[j].add(i);
        }
      }
    }

    boolean[] vis = new boolean[n];
    int[] p = new int[n];
    int[] rank = new int[n];
    for (int i = 0; i < p.length; i++) {
      p[i] = i;
    }
    for (int node : initial) {
      if (!vis[node]) {
        dfs(node, adjList, vis, p, rank);
      }
    }

    Map<Integer, Integer> componentSize = new HashMap<>();

    for (int i = 0; i < n; i++) {
      int pNode = findParent(i, p);
      if (!vis[pNode]) {
        continue;
      }
      componentSize.put(pNode, componentSize.getOrDefault(pNode, 0) + 1);
    }

    int maxComponentSize = 0;
    int res = initial[0];

    for (int node : initial) {
      int pNode = findParent(node, p);
      if (componentSize.get(pNode) > maxComponentSize) {
        maxComponentSize = componentSize.get(pNode);
        res = node;
      }
    }
    return res;
  }

  private void dfs(int node, ArrayList<Integer>[] adjList, boolean[] vis, int[] p, int[] rank) {
    vis[node] = true;
    for (int v : adjList[node]) {
      if (vis[v]) {
        continue;
      }
      union(node, v, p, rank);
      dfs(v, adjList, vis, p, rank);
    }
  }

  private int findParent(int i, int[] p) {
    return p[i] == i ? i : (p[i] = findParent(p[i], p));
  }

  private void union(int i, int j, int[] p, int[] rank) {
    int pi = findParent(i, p);
    int pj = findParent(j, p);
    if (pi == pj) {
      return;
    }
    if (rank[pi] > rank[pj]) {
      p[pj] = pi;
    } else {
      p[pi] = pj;
      if (rank[pi] == rank[pj]) {
        rank[pj]++;
      }
    }
  }

}
