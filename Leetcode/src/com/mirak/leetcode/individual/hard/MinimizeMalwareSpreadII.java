package com.mirak.leetcode.individual.hard;

import java.util.*;

public class MinimizeMalwareSpreadII {

  public int minMalwareSpread(int[][] graph, int[] initial) {
    if (initial.length == 1) {
      return initial[0];
    }

    int n = graph.length;

    boolean[] initiallyInfected = new boolean[n];
    for (int node : initial) {
      initiallyInfected[node] = true;
    }

    DSU dsu = new DSU(n);
    dsu.setupGraph(graph, initiallyInfected);

    Map<Integer, Integer> count = new HashMap<>();

    for (int node : initial) {
      Set<Integer> components = new HashSet<>();
      for (int i = 0; i < n; i++) {
        if (initiallyInfected[i] || graph[node][i] == 0) {
          continue;
        }
        components.add(dsu.findParent(i));
      }
      for (int component : components) {
        count.put(component, count.getOrDefault(component, 0) + 1);
      }
    }

    int removedNode = n + 1;
    int maxRemoved = 0;
    for (int node : initial) {
      int removed = 0;
      for (int i = 0; i < n; i++) {
        if (initiallyInfected[i] || graph[node][i] == 0) {
          continue;
        }
        if (count.get(dsu.findParent(i)) == 1) {
          removed += dsu.componentSize(dsu.findParent(i));
        }
      }
      if (removed > maxRemoved) {
        removedNode = node;
        maxRemoved = removed;
      } else if (removed == maxRemoved) {
        removedNode = Math.min(removedNode, node);
      }
    }
    return removedNode;

  }

  private class DSU {

    int n;
    int[] p, rank, size;

    DSU(int n) {
      this.n = n;
      this.p = new int[n + 1];
      this.rank = new int[n + 1];
      this.size = new int[n + 1];
      init();
    }

    void init() {
      for (int i = 0; i <= n; i++) {
        rank[i] = 0;
        size[i] = 1;
        p[i] = i;
      }
    }

    void setupGraph(int[][] graph, boolean[] initials) {
      for (int i = 0; i < n; i++) {
        if (initials[i]) {
          continue;
        }
        for (int j = 0; j < n; j++) {
          if (i == j || initials[j] || graph[i][j] == 0) {
            continue;
          }
          union(i, j);
        }
      }
    }

    int findParent(int i) {
      return p[i] == i ? i : (p[i] = findParent(p[i]));
    }

    void union(int i, int j) {
      int pi = findParent(i);
      int pj = findParent(j);
      if (pi == pj) {
        return;
      }
      if (rank[pi] > rank[pj]) {
        p[pj] = pi;
        size[pi] += size[pj];
      } else {
        p[pi] = pj;
        size[pj] += size[pi];
        if (rank[pi] == rank[pj]) {
          rank[pj]++;
        }
      }
    }

    int componentSize(int i) {
      return size[findParent(i)];
    }
  }

}
